{
  "version": 3,
  "sources": ["index.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport * as H from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\n\nconst width = 1920; // used by webcam config as well as human maximum resultion // can be anything, but resolutions higher than 4k will disable internal optimizations\n\nconst humanConfig: Partial<H.Config> = { // user configuration for human, used to fine-tune behavior\n  // backend: 'webgpu',\n  modelBasePath: '../../models',\n  filter: { enabled: true, equalization: false, flip: false, width },\n  face: { enabled: true, detector: { rotation: true }, mesh: { enabled: true }, attention: { enabled: false }, iris: { enabled: true }, description: { enabled: true }, emotion: { enabled: true }, antispoof: { enabled: true }, liveness: { enabled: true } },\n  body: { enabled: true },\n  // hand: { enabled: true },\n  hand: { enabled: false },\n  object: { enabled: false },\n  segmentation: { enabled: false },\n  gesture: { enabled: true },\n};\n\nconst human = new H.Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env.perfadd = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n// human.draw.options.fillPolygons = true;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('status') as HTMLPreElement,\n  perf: document.getElementById('performance') as HTMLDivElement,\n};\nconst timestamp = { detect: 0, draw: 0, tensors: 0, start: 0 }; // holds information used to calculate performance and possible memory leaks\nconst fps = { detectFPS: 0, drawFPS: 0, frames: 0, averageMs: 0 }; // holds calculated fps information for both detect and screen refresh\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  console.log(...msg); // eslint-disable-line no-console\n};\nconst status = (msg) => dom.fps.innerText = msg; // print status element\nconst perf = (msg) => dom.perf.innerText = 'tensors:' + human.tf.memory().numTensors.toString() + ' | performance: ' + JSON.stringify(msg).replace(/\"|{|}/g, '').replace(/,/g, ' | '); // print performance element\n\nasync function detectionLoop() { // main detection loop\n  if (!dom.video.paused) {\n    if (timestamp.start === 0) timestamp.start = human.now();\n    // log('profiling data:', await human.profile(dom.video));\n    await human.detect(dom.video); // actual detection; were not capturing output in a local variable as it can also be reached via human.result\n    const tensors = human.tf.memory().numTensors; // check current tensor usage for memory leaks\n    if (tensors - timestamp.tensors !== 0) log('allocated tensors:', tensors - timestamp.tensors); // printed on start and each time there is a tensor leak\n    timestamp.tensors = tensors;\n    fps.detectFPS = Math.round(1000 * 1000 / (human.now() - timestamp.detect)) / 1000;\n    fps.frames++;\n    fps.averageMs = Math.round(1000 * (human.now() - timestamp.start) / fps.frames) / 1000;\n    if (fps.frames % 100 === 0 && !dom.video.paused) log('performance', { ...fps, tensors: timestamp.tensors });\n  }\n  timestamp.detect = human.now();\n  requestAnimationFrame(detectionLoop); // start new frame immediately\n}\n\nasync function drawLoop() { // main screen refresh loop\n  if (!dom.video.paused) {\n    const interpolated = human.next(human.result); // smoothen result using last-known results\n    const processed = await human.image(dom.video); // get current video frame, but enhanced with human.filters\n    human.draw.canvas(processed.canvas as HTMLCanvasElement, dom.canvas);\n\n    const opt: Partial<H.DrawOptions> = { bodyLabels: `person confidence [score] and ${human.result?.body?.[0]?.keypoints.length} keypoints` };\n    await human.draw.all(dom.canvas, interpolated, opt); // draw labels, boxes, lines, etc.\n    perf(interpolated.performance); // write performance data\n  }\n  const now = human.now();\n  fps.drawFPS = Math.round(1000 * 1000 / (now - timestamp.draw)) / 1000;\n  timestamp.draw = now;\n  status(dom.video.paused ? 'paused' : `fps: ${fps.detectFPS.toFixed(1).padStart(5, ' ')} detect | ${fps.drawFPS.toFixed(1).padStart(5, ' ')} draw`); // write status\n  setTimeout(drawLoop, 30); // use to slow down refresh from max refresh rate to target of 30 fps\n}\n\nasync function webCam() {\n  const devices = await human.webcam.enumerate();\n  const id = devices[0].deviceId; // use first available video source\n  await human.webcam.start({ element: dom.video, crop: true, width, id }); // use human webcam helper methods and associate webcam stream with a dom element\n  dom.canvas.width = human.webcam.width;\n  dom.canvas.height = human.webcam.height;\n  dom.canvas.onclick = async () => { // pause when clicked on screen and resume on next click\n    if (human.webcam.paused) await human.webcam.play();\n    else human.webcam.pause();\n  };\n}\n\nasync function main() { // main entry point\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('platform:', human.env.platform, '| agent:', human.env.agent);\n  status('loading...');\n  await human.load(); // preload all models\n  log('backend:', human.tf.getBackend(), '| available:', human.env.backends);\n  log('models stats:', human.getModelStats());\n  log('models loaded:', Object.values(human.models).filter((model) => model !== null).length);\n  log('environment', human.env);\n  status('initializing...');\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await webCam(); // start webcam\n  await detectionLoop(); // start detection loop\n  await drawLoop(); // start draw loop\n}\n\nwindow.onload = main;\n"],
  "mappings": "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",
  "names": []
}
