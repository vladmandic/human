{
  "version": 3,
  "sources": ["index.ts", "indexdb.ts"],
  "sourcesContent": ["/**\n * Human demo for browsers\n * @default Human Library\n * @summary <https://github.com/vladmandic/human>\n * @author <https://github.com/vladmandic>\n * @copyright <https://github.com/vladmandic>\n * @license MIT\n */\n\nimport * as H from '../../dist/human.esm.js'; // equivalent of @vladmandic/Human\nimport * as indexDb from './indexdb'; // methods to deal with indexdb\n\nconst humanConfig = { // user configuration for human, used to fine-tune behavior\n  cacheSensitivity: 0,\n  modelBasePath: '../../models',\n  filter: { enabled: true, equalization: true }, // lets run with histogram equilizer\n  debug: true,\n  face: {\n    enabled: true,\n    detector: { rotation: true, return: true, cropFactor: 1.6, mask: false }, // return tensor is used to get detected face image\n    description: { enabled: true }, // default model for face descriptor extraction is faceres\n    // mobilefacenet: { enabled: true, modelPath: 'https://vladmandic.github.io/human-models/models/mobilefacenet.json' }, // alternative model\n    // insightface: { enabled: true, modelPath: 'https://vladmandic.github.io/insightface/models/insightface-mobilenet-swish.json' }, // alternative model\n    iris: { enabled: true }, // needed to determine gaze direction\n    emotion: { enabled: false }, // not needed\n    antispoof: { enabled: true }, // enable optional antispoof module\n    liveness: { enabled: true }, // enable optional liveness module\n  },\n  body: { enabled: false },\n  hand: { enabled: false },\n  object: { enabled: false },\n  gesture: { enabled: true }, // parses face and iris gestures\n};\n\n// const matchOptions = { order: 2, multiplier: 1000, min: 0.0, max: 1.0 }; // for embedding model\nconst matchOptions = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }; // for faceres model\n\nconst options = {\n  minConfidence: 0.6, // overal face confidence for box, face, gender, real, live\n  minSize: 224, // min input to face descriptor model before degradation\n  maxTime: 30000, // max time before giving up\n  blinkMin: 10, // minimum duration of a valid blink\n  blinkMax: 800, // maximum duration of a valid blink\n  threshold: 0.5, // minimum similarity\n  distanceMin: 0.4, // closest that face is allowed to be to the cammera in cm\n  distanceMax: 1.0, // farthest that face is allowed to be to the cammera in cm\n  mask: humanConfig.face.detector.mask,\n  rotation: humanConfig.face.detector.rotation,\n  cropFactor: humanConfig.face.detector.cropFactor,\n  ...matchOptions,\n};\n\nconst ok: Record<string, { status: boolean | undefined, val: number }> = { // must meet all rules\n  faceCount: { status: false, val: 0 },\n  faceConfidence: { status: false, val: 0 },\n  facingCenter: { status: false, val: 0 },\n  lookingCenter: { status: false, val: 0 },\n  blinkDetected: { status: false, val: 0 },\n  faceSize: { status: false, val: 0 },\n  antispoofCheck: { status: false, val: 0 },\n  livenessCheck: { status: false, val: 0 },\n  distance: { status: false, val: 0 },\n  age: { status: false, val: 0 },\n  gender: { status: false, val: 0 },\n  timeout: { status: true, val: 0 },\n  descriptor: { status: false, val: 0 },\n  elapsedMs: { status: undefined, val: 0 }, // total time while waiting for valid face\n  detectFPS: { status: undefined, val: 0 }, // mark detection fps performance\n  drawFPS: { status: undefined, val: 0 }, // mark redraw fps performance\n};\n\nconst allOk = () => ok.faceCount.status\n  && ok.faceSize.status\n  && ok.blinkDetected.status\n  && ok.facingCenter.status\n  && ok.lookingCenter.status\n  && ok.faceConfidence.status\n  && ok.antispoofCheck.status\n  && ok.livenessCheck.status\n  && ok.distance.status\n  && ok.descriptor.status\n  && ok.age.status\n  && ok.gender.status;\n\nconst current: { face: H.FaceResult | null, record: indexDb.FaceRecord | null } = { face: null, record: null }; // current face record and matched database record\n\nconst blink = { // internal timers for blink start/end/duration\n  start: 0,\n  end: 0,\n  time: 0,\n};\n\n// let db: Array<{ name: string, source: string, embedding: number[] }> = []; // holds loaded face descriptor database\nconst human = new H.Human(humanConfig); // create instance of human with overrides from user configuration\n\nhuman.env.perfadd = false; // is performance data showing instant or total values\nhuman.draw.options.font = 'small-caps 18px \"Lato\"'; // set font used to draw labels when using draw methods\nhuman.draw.options.lineHeight = 20;\n\nconst dom = { // grab instances of dom objects so we dont have to look them up later\n  video: document.getElementById('video') as HTMLVideoElement,\n  canvas: document.getElementById('canvas') as HTMLCanvasElement,\n  log: document.getElementById('log') as HTMLPreElement,\n  fps: document.getElementById('fps') as HTMLPreElement,\n  match: document.getElementById('match') as HTMLDivElement,\n  name: document.getElementById('name') as HTMLInputElement,\n  save: document.getElementById('save') as HTMLSpanElement,\n  delete: document.getElementById('delete') as HTMLSpanElement,\n  retry: document.getElementById('retry') as HTMLDivElement,\n  source: document.getElementById('source') as HTMLCanvasElement,\n  ok: document.getElementById('ok') as HTMLDivElement,\n};\nconst timestamp = { detect: 0, draw: 0 }; // holds information used to calculate performance and possible memory leaks\nlet startTime = 0;\n\nconst log = (...msg) => { // helper method to output messages\n  dom.log.innerText += msg.join(' ') + '\\n';\n  console.log(...msg); // eslint-disable-line no-console\n};\n\nasync function webCam() { // initialize webcam\n  // @ts-ignore resizeMode is not yet defined in tslib\n  const cameraOptions: MediaStreamConstraints = { audio: false, video: { facingMode: 'user', resizeMode: 'none', width: { ideal: document.body.clientWidth } } };\n  const stream: MediaStream = await navigator.mediaDevices.getUserMedia(cameraOptions);\n  const ready = new Promise((resolve) => { dom.video.onloadeddata = () => resolve(true); });\n  dom.video.srcObject = stream;\n  void dom.video.play();\n  await ready;\n  dom.canvas.width = dom.video.videoWidth;\n  dom.canvas.height = dom.video.videoHeight;\n  dom.canvas.style.width = '50%';\n  dom.canvas.style.height = '50%';\n  if (human.env.initial) log('video:', dom.video.videoWidth, dom.video.videoHeight, '|', stream.getVideoTracks()[0].label);\n  dom.canvas.onclick = () => { // pause when clicked on screen and resume on next click\n    if (dom.video.paused) void dom.video.play();\n    else dom.video.pause();\n  };\n}\n\nasync function detectionLoop() { // main detection loop\n  if (!dom.video.paused) {\n    if (current.face?.tensor) human.tf.dispose(current.face.tensor); // dispose previous tensor\n    await human.detect(dom.video); // actual detection; were not capturing output in a local variable as it can also be reached via human.result\n    const now = human.now();\n    ok.detectFPS.val = Math.round(10000 / (now - timestamp.detect)) / 10;\n    timestamp.detect = now;\n    requestAnimationFrame(detectionLoop); // start new frame immediately\n  }\n}\n\nfunction drawValidationTests() {\n  let y = 32;\n  for (const [key, val] of Object.entries(ok)) {\n    let el = document.getElementById(`ok-${key}`);\n    if (!el) {\n      el = document.createElement('div');\n      el.id = `ok-${key}`;\n      el.innerText = key;\n      el.className = 'ok';\n      el.style.top = `${y}px`;\n      dom.ok.appendChild(el);\n    }\n    if (typeof val.status === 'boolean') el.style.backgroundColor = val.status ? 'lightgreen' : 'lightcoral';\n    const status = val.status ? 'ok' : 'fail';\n    el.innerText = `${key}: ${val.val === 0 ? status : val.val}`;\n    y += 28;\n  }\n}\n\nasync function validationLoop(): Promise<H.FaceResult> { // main screen refresh loop\n  const interpolated = human.next(human.result); // smoothen result using last-known results\n  human.draw.canvas(dom.video, dom.canvas); // draw canvas to screen\n  await human.draw.all(dom.canvas, interpolated); // draw labels, boxes, lines, etc.\n  const now = human.now();\n  ok.drawFPS.val = Math.round(10000 / (now - timestamp.draw)) / 10;\n  timestamp.draw = now;\n  ok.faceCount.val = human.result.face.length;\n  ok.faceCount.status = ok.faceCount.val === 1; // must be exactly detected face\n  if (ok.faceCount.status) { // skip the rest if no face\n    const gestures: string[] = Object.values(human.result.gesture).map((gesture: H.GestureResult) => gesture.gesture); // flatten all gestures\n    if (gestures.includes('blink left eye') || gestures.includes('blink right eye')) blink.start = human.now(); // blink starts when eyes get closed\n    if (blink.start > 0 && !gestures.includes('blink left eye') && !gestures.includes('blink right eye')) blink.end = human.now(); // if blink started how long until eyes are back open\n    ok.blinkDetected.status = ok.blinkDetected.status || (Math.abs(blink.end - blink.start) > options.blinkMin && Math.abs(blink.end - blink.start) < options.blinkMax);\n    if (ok.blinkDetected.status && blink.time === 0) blink.time = Math.trunc(blink.end - blink.start);\n    ok.facingCenter.status = gestures.includes('facing center');\n    ok.lookingCenter.status = gestures.includes('looking center'); // must face camera and look at camera\n    ok.faceConfidence.val = human.result.face[0].faceScore || human.result.face[0].boxScore || 0;\n    ok.faceConfidence.status = ok.faceConfidence.val >= options.minConfidence;\n    ok.antispoofCheck.val = human.result.face[0].real || 0;\n    ok.antispoofCheck.status = ok.antispoofCheck.val >= options.minConfidence;\n    ok.livenessCheck.val = human.result.face[0].live || 0;\n    ok.livenessCheck.status = ok.livenessCheck.val >= options.minConfidence;\n    ok.faceSize.val = Math.min(human.result.face[0].box[2], human.result.face[0].box[3]);\n    ok.faceSize.status = ok.faceSize.val >= options.minSize;\n    ok.distance.val = human.result.face[0].distance || 0;\n    ok.distance.status = (ok.distance.val >= options.distanceMin) && (ok.distance.val <= options.distanceMax);\n    ok.descriptor.val = human.result.face[0].embedding?.length || 0;\n    ok.descriptor.status = ok.descriptor.val > 0;\n    ok.age.val = human.result.face[0].age || 0;\n    ok.age.status = ok.age.val > 0;\n    ok.gender.val = human.result.face[0].genderScore || 0;\n    ok.gender.status = ok.gender.val >= options.minConfidence;\n  }\n  // run again\n  ok.timeout.status = ok.elapsedMs.val <= options.maxTime;\n  drawValidationTests();\n  if (allOk() || !ok.timeout.status) { // all criteria met\n    dom.video.pause();\n    return human.result.face[0];\n  }\n  ok.elapsedMs.val = Math.trunc(human.now() - startTime);\n  return new Promise((resolve) => {\n    setTimeout(async () => {\n      await validationLoop(); // run validation loop until conditions are met\n      resolve(human.result.face[0]); // recursive promise resolve\n    }, 30); // use to slow down refresh from max refresh rate to target of 30 fps\n  });\n}\n\nasync function saveRecords() {\n  if (dom.name.value.length > 0) {\n    const image = dom.canvas.getContext('2d')?.getImageData(0, 0, dom.canvas.width, dom.canvas.height) as ImageData;\n    const rec = { id: 0, name: dom.name.value, descriptor: current.face?.embedding as number[], image };\n    await indexDb.save(rec);\n    log('saved face record:', rec.name, 'descriptor length:', current.face?.embedding?.length);\n    log('known face records:', await indexDb.count());\n  } else {\n    log('invalid name');\n  }\n}\n\nasync function deleteRecord() {\n  if (current.record && current.record.id > 0) {\n    await indexDb.remove(current.record);\n  }\n}\n\nasync function detectFace() {\n  dom.canvas.style.height = '';\n  dom.canvas.getContext('2d')?.clearRect(0, 0, options.minSize, options.minSize);\n  if (!current?.face?.tensor || !current?.face?.embedding) return false;\n  console.log('face record:', current.face); // eslint-disable-line no-console\n  log(`detected face: ${current.face.gender} ${current.face.age || 0}y distance ${100 * (current.face.distance || 0)}cm/${Math.round(100 * (current.face.distance || 0) / 2.54)}in`);\n  await human.tf.browser.toPixels(current.face.tensor, dom.canvas);\n  if (await indexDb.count() === 0) {\n    log('face database is empty: nothing to compare face with');\n    document.body.style.background = 'black';\n    dom.delete.style.display = 'none';\n    return false;\n  }\n  const db = await indexDb.load();\n  const descriptors = db.map((rec) => rec.descriptor).filter((desc) => desc.length > 0);\n  const res = human.match.find(current.face.embedding, descriptors, matchOptions);\n  current.record = db[res.index] || null;\n  if (current.record) {\n    log(`best match: ${current.record.name} | id: ${current.record.id} | similarity: ${Math.round(1000 * res.similarity) / 10}%`);\n    dom.name.value = current.record.name;\n    dom.source.style.display = '';\n    dom.source.getContext('2d')?.putImageData(current.record.image, 0, 0);\n  }\n  document.body.style.background = res.similarity > options.threshold ? 'darkgreen' : 'maroon';\n  return res.similarity > options.threshold;\n}\n\nasync function main() { // main entry point\n  ok.faceCount.status = false;\n  ok.faceConfidence.status = false;\n  ok.facingCenter.status = false;\n  ok.blinkDetected.status = false;\n  ok.faceSize.status = false;\n  ok.antispoofCheck.status = false;\n  ok.livenessCheck.status = false;\n  ok.age.status = false;\n  ok.gender.status = false;\n  ok.elapsedMs.val = 0;\n  dom.match.style.display = 'none';\n  dom.retry.style.display = 'none';\n  dom.source.style.display = 'none';\n  dom.canvas.style.height = '50%';\n  document.body.style.background = 'black';\n  await webCam();\n  await detectionLoop(); // start detection loop\n  startTime = human.now();\n  current.face = await validationLoop(); // start validation loop\n  dom.canvas.width = current.face?.tensor?.shape[1] || options.minSize;\n  dom.canvas.height = current.face?.tensor?.shape[0] || options.minSize;\n  dom.source.width = dom.canvas.width;\n  dom.source.height = dom.canvas.height;\n  dom.canvas.style.width = '';\n  dom.match.style.display = 'flex';\n  dom.save.style.display = 'flex';\n  dom.delete.style.display = 'flex';\n  dom.retry.style.display = 'block';\n  if (!allOk()) { // is all criteria met?\n    log('did not find valid face');\n    return false;\n  }\n  return detectFace();\n}\n\nasync function init() {\n  log('human version:', human.version, '| tfjs version:', human.tf.version['tfjs-core']);\n  log('options:', JSON.stringify(options).replace(/{|}|\"|\\[|\\]/g, '').replace(/,/g, ' '));\n  log('initializing webcam...');\n  await webCam(); // start webcam\n  log('loading human models...');\n  await human.load(); // preload all models\n  log('initializing human...');\n  log('face embedding model:', humanConfig.face.description.enabled ? 'faceres' : '', humanConfig.face['mobilefacenet']?.enabled ? 'mobilefacenet' : '', humanConfig.face['insightface']?.enabled ? 'insightface' : '');\n  log('loading face database...');\n  log('known face records:', await indexDb.count());\n  dom.retry.addEventListener('click', main);\n  dom.save.addEventListener('click', saveRecords);\n  dom.delete.addEventListener('click', deleteRecord);\n  await human.warmup(); // warmup function to initialize backend for future faster detection\n  await main();\n}\n\nwindow.onload = init;\n", "let db: IDBDatabase; // instance of indexdb\n\nconst database = 'human';\nconst table = 'person';\n\nexport interface FaceRecord { id: number, name: string, descriptor: number[], image: ImageData }\n\nconst log = (...msg) => console.log('indexdb', ...msg); // eslint-disable-line no-console\n\nexport async function open() {\n  if (db) return true;\n  return new Promise((resolve) => {\n    const request: IDBOpenDBRequest = indexedDB.open(database, 1);\n    request.onerror = (evt) => log('error:', evt);\n    request.onupgradeneeded = (evt: IDBVersionChangeEvent) => { // create if doesnt exist\n      log('create:', evt.target);\n      db = (evt.target as IDBOpenDBRequest).result;\n      db.createObjectStore(table, { keyPath: 'id', autoIncrement: true });\n    };\n    request.onsuccess = (evt) => { // open\n      db = (evt.target as IDBOpenDBRequest).result;\n      log('open:', db);\n      resolve(true);\n    };\n  });\n}\n\nexport async function load(): Promise<FaceRecord[]> {\n  const faceDB: FaceRecord[] = [];\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const cursor: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).openCursor(null, 'next');\n    cursor.onerror = (evt) => log('load error:', evt);\n    cursor.onsuccess = (evt) => {\n      if ((evt.target as IDBRequest).result) {\n        faceDB.push((evt.target as IDBRequest).result.value);\n        (evt.target as IDBRequest).result.continue();\n      } else {\n        resolve(faceDB);\n      }\n    };\n  });\n}\n\nexport async function count(): Promise<number> {\n  if (!db) await open(); // open or create if not already done\n  return new Promise((resolve) => {\n    const store: IDBRequest = db.transaction([table], 'readwrite').objectStore(table).count();\n    store.onerror = (evt) => log('count error:', evt);\n    store.onsuccess = () => resolve(store.result);\n  });\n}\n\nexport async function save(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  const newRecord = { name: faceRecord.name, descriptor: faceRecord.descriptor, image: faceRecord.image }; // omit id as its autoincrement\n  db.transaction([table], 'readwrite').objectStore(table).put(newRecord);\n  log('save:', newRecord);\n}\n\nexport async function remove(faceRecord: FaceRecord) {\n  if (!db) await open(); // open or create if not already done\n  db.transaction([table], 'readwrite').objectStore(table).delete(faceRecord.id); // delete based on id\n  log('delete:', faceRecord);\n}\n"],
  "mappings": "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",
  "names": ["log", "db"]
}
